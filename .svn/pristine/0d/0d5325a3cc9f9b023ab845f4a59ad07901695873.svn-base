/*
 * simcom.c
 *
 *  Created on: Aug 14, 2019
 *      Author: Puja
 */
#include <_simcom.h>

/* Private typedef -----------------------------------------------------------*/
typedef struct {
	char 	datetime[15];
	char 	longitude[20];
	char 	latitude[20];
	char	heading[5];
	char 	hdop[5];
} sim_data_gps_t;

typedef struct {
	char 			datetime_rtc[15];
	uint8_t		reportd_id;
	uint32_t 	odometer;
	uint8_t		status_input;
	char			speed[5];
	uint8_t		status_output;
	uint16_t	analog_input;
	char			driver_id[17];
	int16_t		temp_sensor1;
	int16_t		temp_sensor2;
	char			message[SIMCOM_MESSAGE_LENGTH];
	sim_data_gps_t	gps;
} sim_data_t;

typedef struct {
	char 			prefix[3];
	uint16_t 	crc;
	uint16_t 	length;
	uint16_t 	seq_id;
	char	 		unit_id[10];
} sim_header_t;

typedef struct {
	sim_header_t 	header;
	sim_data_t		data;
} sim_t;

/* Private functions ---------------------------------------------------------*/
static void Simcom_On(void);
static void Simcom_Reset(void);
static uint8_t Simcom_Response(char *str);
static uint8_t Simcom_Send(char *cmd, uint32_t ms);
static uint8_t Simcom_Send_Repeat(char *command, uint32_t ms, char *response);
static void Simcom_Set_Default_Data(void);
static uint8_t Simcom_Boot(void);

/* External variable ---------------------------------------------------------*/
extern char SIMCOM_UART_RX_Buffer[SIMCOM_UART_RX_BUFFER_SIZE];
extern osMutexId SimcomRecMutexHandle;
extern osThreadId CommandTaskHandle;
/* Private variable ---------------------------------------------------------*/
char 		str[SIMCOM_UART_RX_BUFFER_SIZE];
char 		CIPSEND[50];
char 		CIPOPEN[50];
//position
char 		POSITION_HEADER[SIMCOM_POS_HEADER_LENGTH];
char 		POSITION_DATA[SIMCOM_POS_DATA_LENGTH];
char 		PAYLOAD[SIMCOM_POS_HEADER_LENGTH+SIMCOM_POS_DATA_LENGTH];
//simcom struct
sim_t 	sim;

/* USER CODE END PV */
void Ublox_Init(gps_t *hgps){
	HAL_GPIO_WritePin(UBLOX_PWR_GPIO_Port, UBLOX_PWR_Pin, GPIO_PIN_SET);
	osDelay(50);
	gps_init(hgps);
}

static void Simcom_On(void){
	HAL_GPIO_WritePin(SIMCOM_PWR_GPIO_Port, SIMCOM_PWR_Pin, GPIO_PIN_RESET);
	osDelay(70);
	HAL_GPIO_WritePin(SIMCOM_PWR_GPIO_Port, SIMCOM_PWR_Pin, GPIO_PIN_SET);
	osDelay(50);
}

static void Simcom_Reset(void){
	HAL_GPIO_WritePin(SIMCOM_RST_GPIO_Port, SIMCOM_RST_Pin, GPIO_PIN_RESET);
	osDelay(10);
	HAL_GPIO_WritePin(SIMCOM_RST_GPIO_Port, SIMCOM_RST_Pin, GPIO_PIN_SET);
	osDelay(50);
}

static uint8_t Simcom_Boot(void){
	uint32_t tick;
	uint64_t timeout_tick;

	// reset the state of simcom module
	Simcom_Reset();
	// turn off sequence
	Simcom_On();
	// set timeout guard (for first boot always 20 second)
	timeout_tick = osKernelSysTickMicroSec(20*1000*1000);
	tick = osKernelSysTick();
	// wait until booting is done
	while ( !(Simcom_Response(SIMCOM_STATUS_READY) || (osKernelSysTick() - tick) > timeout_tick) );
	// handle timeout
	return (uint8_t) ((osKernelSysTick() - tick) < timeout_tick);
}

static uint8_t Simcom_Response(char *str)
{
	if (strstr(SIMCOM_UART_RX_Buffer, str) != NULL)
	{
		return 1;
	}
	return 0;
}

static uint8_t Simcom_Send(char *cmd, uint32_t ms)
{
	osRecursiveMutexWait(SimcomRecMutexHandle, osWaitForever);

	uint8_t ret;
	uint32_t tick, timeout_tick;
	// reset rx buffer
	SIMCOM_Reset_Buffer();
	// transmit to serial
	SIMCOM_Transmit(cmd, strlen(cmd));
	// convert time to tick
	timeout_tick = osKernelSysTickMicroSec(SIMCOM_CMD_TIMEOUT*1000*1000);
	// set timeout guard
	tick = osKernelSysTick();
	// wait for response to complete
	if(strstr(cmd, SIMCOM_MESSAGE_END) == NULL) {
		osDelay(200 + ms);
	}
	// wait response from SIMCOM
	while ( !(Simcom_Response(SIMCOM_STATUS_SEND) || Simcom_Response(SIMCOM_STATUS_CIPSEND) || Simcom_Response(SIMCOM_STATUS_OK) || Simcom_Response(SIMCOM_STATUS_RESTARTED) || Simcom_Response(SIMCOM_STATUS_ERROR) || (osKernelSysTick() - tick) >= timeout_tick) );
	// handle timeout & error
	if ( Simcom_Response(SIMCOM_STATUS_ERROR) || Simcom_Response(SIMCOM_STATUS_RESTARTED) || (osKernelSysTick() - tick) > timeout_tick ){
		ret = 0;
	} else {
		ret = 1;
	}
	// print for debugger
	if(strstr(cmd, SIMCOM_MESSAGE_END) == NULL) {
		sprintf(str, "\n=> %s", cmd);
		swvPrint(str);
	}
	sprintf(str, "%s\n", SIMCOM_UART_RX_Buffer);
	swvPrint(str);
	// check if it has new command
	Simcom_Check_Command();

	osRecursiveMutexRelease(SimcomRecMutexHandle);
	return ret;
}

static uint8_t Simcom_Send_Repeat(char *command, uint32_t ms, char *response)
{
	osRecursiveMutexWait(SimcomRecMutexHandle, osWaitForever);

	uint8_t ret = 1, seq = 1, seq_max = 5;
	// repeat command until desired response
	do {
		if(seq > 1) {
			// execute command every timeout guard elapsed
			osDelay(SIMCOM_CMD_TIMEOUT*500);
		}
		// send command
		if (seq <= seq_max) {
			Simcom_Send(command, ms);
			// if device error, break
			if (Simcom_Response(SIMCOM_STATUS_RESTARTED)) {
				ret = 0;
				break;
			}
		} else {
			// if until max sequence still error, break
			ret = 0;
			break;
		}
		// increment sequence
		seq++;
	} while (!Simcom_Response(response));

	osRecursiveMutexRelease(SimcomRecMutexHandle);
	return ret;
}

static void Simcom_Set_Default_Data(void){
	// set initial data
	strcpy(sim.header.prefix, "@P");
	strcpy(sim.header.unit_id, "354453");
	sim.header.crc = 0;
	sim.header.length = 0;
	sim.header.seq_id = 0;

	strcpy(sim.data.datetime_rtc, "");
	strcpy(sim.data.speed, "0");
	strcpy(sim.data.driver_id, "31313");
	strcpy(sim.data.message, "");
	sim.data.reportd_id = 2;
	sim.data.odometer = Flash_Get_Odometer();
	sim.data.status_input = 0;
	sim.data.status_output = 0;
	sim.data.analog_input = 0;
	sim.data.temp_sensor1 = 2000;
	sim.data.temp_sensor2 = 2000;

	strcpy(sim.data.gps.datetime, "");
	strcpy(sim.data.gps.longitude, "0");
	strcpy(sim.data.gps.latitude, "0");
	strcpy(sim.data.gps.heading, "108");
	strcpy(sim.data.gps.hdop, "0");
	strcpy(sim.data.gps.datetime, "");
	// prepare command sequence
	sprintf(CIPSEND, "AT+CIPSEND=0,,\"%s\",%d\r", SERVER_IP, SERVER_PORT);
	sprintf(CIPOPEN, "AT+CIPOPEN=0,\"UDP\",,,%d\r", LOCAL_PORT);
}

void Simcom_Init(uint8_t restart){
	uint8_t p, boot = !restart;

	// this do-while is complicated, but it doesn't use recursive function, so it's stack safe
	do {
		p = 0;
		// Turn on the module & wait till ready
		if(boot){
			p = Simcom_Boot();
			// Execute only on first setup
			if(p && !restart) {
				//set default value to variable
				Simcom_Set_Default_Data();
				//disable command echo
				p = Simcom_Send("ATE1\r", 0);
				//set permanent baudrate
				if(p){
					p = Simcom_Send("AT+IPREX=9600\r", 0);
				}
				//save user setting to ME
				if(p){
					p = Simcom_Send("AT&W\r", 0);
				}
			}
			// if boot sequence ok, then disable it
			boot = !p;
		} else {
			p = 1;
		}
		//Lock to WCDMA
		if(p){
			// 2: Auto, 13: 2G, 14: 3G
			p = Simcom_Send("AT+CNMP=2\r", 0);
		}
		//Hide “+IPD” header
		if(p){
			p = Simcom_Send("AT+CIPHEAD=0\r", 0);
		}
		//Hide “RECV FROM” header
		if(p){
			p = Simcom_Send("AT+CIPSRIP=0\r", 0);
		}
		//Set module to cache received data.
		if(p){
			p = Simcom_Send("AT+CIPRXGET=1\r", 0);
		}
		//Inquiring UE system information
		if(p){
			p = Simcom_Send_Repeat("AT+CPSI?\r", 0, ",Online,");
			// restart module to fix it
			boot = !p;
		}
		//Define socket PDP context (APN Settings)
		if(p){
			p = Simcom_Send("AT+CGSOCKCONT=1,\"IP\",\"telkomsel\"\r", 0);
		}
		//Set active PDP context profile number
		if(p){
			p = Simcom_Send("AT+CSOCKSETPN=1\r", 0);
		}
		//Set type of authentication for PDP-IP connections of socket
		if(p){
			p = Simcom_Send("AT+CSOCKAUTH=1,1,\"wap\",\"wap123\"\r", 0);
		}
		//Select TCPIP application mode (0: Non Transparent (command mode), 1: Transparent (data mode))
		if(p){
			p = Simcom_Send("AT+CIPMODE=0\r", 0);
		}
		//Open network
		if(p){
			p = Simcom_Send("AT+NETOPEN\r", 500);
		}
		//Open local UDP Connection
		if(p){
			p = Simcom_Send_Repeat(CIPOPEN, 500, SIMCOM_STATUS_OK);
			// restart module to fix it
			boot = !p;
		}
	} while(p == 0);
}

void Simcom_Set_Message(char* msg){
	sprintf(sim.data.message, "%s\x1E", msg);
}

void Simcom_Convert_GPS(gps_t *hgps){
	// parse gps data
	if(hgps->fix > 0){
		Simcom_Set_Odometer(sim.data.odometer + ( gps_to_speed(hgps->speed, gps_speed_mps) * REPORT_INTERVAL ));
		ftoa(hgps->latitude, sim.data.gps.latitude, 6);
		ftoa(hgps->longitude, sim.data.gps.longitude, 6);
		ftoa(hgps->dop_h, sim.data.gps.hdop, 3);
		ftoa(gps_to_speed(hgps->speed, gps_speed_kph), sim.data.speed, 1);
		sprintf(sim.data.gps.datetime, "20%02d%02d%02d%02d%02d%02d", hgps->year, hgps->month, hgps->date, convertHourTo(hgps->hours, GMT_TIME), hgps->minutes, hgps->seconds);
	}
}

void Simcom_Set_Payload(void)
{
	// parse rtc datetime
	Get_RTC(sim.data.datetime_rtc);
	//Reconstruct the data
	sprintf(
			POSITION_DATA,
			"%s,%s,%s,%s,%s,"
			"%s,%d,%lu,%s,%d,"
			"%s,%d,%d,%s,%d,"
			"%d,%s\r\n",
			sim.data.gps.datetime, sim.data.datetime_rtc, sim.data.datetime_rtc, sim.data.gps.longitude, sim.data.gps.latitude,
			sim.data.gps.heading, sim.data.reportd_id, sim.data.odometer, sim.data.gps.hdop, sim.data.status_input,
			sim.data.speed,	sim.data.status_output,	sim.data.analog_input, sim.data.driver_id, sim.data.temp_sensor1,
			sim.data.temp_sensor2, sim.data.message);
	//Reconstruct the header
	sim.header.length = strlen(POSITION_DATA);
	sim.header.seq_id++;
	sprintf(
			POSITION_HEADER,
			"%s,%d,%d,%d,%s",
			sim.header.prefix, sim.header.crc, sim.header.length, sim.header.seq_id, sim.header.unit_id);
	//Reconstruct the position
	sprintf(PAYLOAD, "%s,%s", POSITION_HEADER, POSITION_DATA);
}

uint8_t Simcom_Send_Payload(void){
	return Simcom_To_Server(PAYLOAD, strlen(PAYLOAD));
}

uint8_t Simcom_To_Server(char *message, uint16_t length) {
	osRecursiveMutexWait(SimcomRecMutexHandle, osWaitForever);

	uint8_t ret = 0;
	char str[length+1];
	// add message end character
	sprintf(str, "%s%s", message, SIMCOM_MESSAGE_END);
	// confirm to server that command is executed
	if (Simcom_Send(CIPSEND, 0)) {
		// send response
		if(Simcom_Send(str, 0)){
			ret = 1;
		}
	}

	osRecursiveMutexRelease(SimcomRecMutexHandle);
	return ret;
}

void Simcom_Check_Command(void)
{
	// check if it has new command
	if (strstr(SIMCOM_UART_RX_Buffer, "+CIPRXGET: 1") != NULL){
		// hand over command to CommandTask
		xTaskNotifyGive( CommandTaskHandle );
	}
}

uint8_t Simcom_Get_Command(command_t *command){
	osRecursiveMutexWait(SimcomRecMutexHandle, osWaitForever);

	uint8_t ret = 0;
	char *start, *delim, *end;

	if(Simcom_Send("AT+CIPRXGET=2,0\r", 0)){
		// get pointer reference
		start = strstr(SIMCOM_UART_RX_Buffer, "AT$");
		end   = strstr(start, "\r\n\r\n");
		delim = strchr(start, '=');

		// check if command has value
		if(delim != NULL){
			// get command
			strncpy(command->var, start + 3, delim - (start + 3));
			*(command->var + (delim - (start + 3))) = '\0';
			// get value
			strncpy(command->val, delim + 1, end - delim);
			*(command->val + (end - delim)) = '\0';
		} else {
			// get command
			strncpy(command->var, start + 3, end - (start + 3));
			*(command->var + (end - (start + 3))) = '\0';
			// set value
			*(command->val) = '\0';
		}

		// get full command
		strncpy(command->cmd, start + 3, end - (start + 3));
		*(command->cmd + (end - (start + 3))) = '\0';

		// reset rx buffer
		SIMCOM_Reset_Buffer();

		ret = 1;
	}

	osRecursiveMutexRelease(SimcomRecMutexHandle);
	return ret;
}

void Simcom_Set_Odometer(uint32_t odom){
	sim.data.odometer = odom;
	Flash_Save_Odometer(odom);
}
