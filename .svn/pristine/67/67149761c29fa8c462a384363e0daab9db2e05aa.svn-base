/*
 * _config.c
 *
 *  Created on: Aug 26, 2019
 *      Author: Puja
 */

#include "_config.h"

extern osMutexId SwvMutexHandle;
extern RTC_HandleTypeDef hrtc;

void ITM_Out(uint32_t ch) {
#if (DEBUG_HUB == 1)
	int port = 0;

	while (ITM->PORT[port].u32 == 0)
		;
	ITM->PORT[port].u8 = (uint8_t) ch;
#endif
}

void swvPrint(char* ptr) {
	osMutexWait(SwvMutexHandle, osWaitForever);

	while (*ptr != '\0') {
		ITM_Out((uint32_t) *(ptr++));
	}

	osMutexRelease(SwvMutexHandle);
}

void swvPrintLn(char* ptr) {
	osMutexWait(SwvMutexHandle, osWaitForever);

	while (*ptr != '\0') {
		ITM_Out((uint32_t) *(ptr++));
	}
	ITM_Out((uint32_t) '\n');

	osMutexRelease(SwvMutexHandle);
}

void swvPrintDebug(char* var, char* value) {
	swvPrint("\n===============================\n");
	swvPrint(var);
	swvPrint(" => ");
	swvPrint(value);
	swvPrint("\n===============================\n");
}

// Converts a floating point number to string.
void ftoa(float f, char *str, char size) {
	uint8_t pos;  // position in string
	char len;  // length of decimal part of result
	char curr[100];  // temp holder for next digit
	int value;  // decimal digit(s) to convert
	pos = 0;  // initialize pos, just to be sure

	value = (int) f;  // truncate the floating point number
	itoa(value, str, 10);  // this is kinda dangerous depending on the length of str
	// now str array has the digits before the decimal

	if (f < 0)  // handle negative numbers
			{
		f *= -1;
		value *= -1;
	}

	len = strlen(str);  // find out how big the integer part was
	pos = len;  // position the pointer to the end of the integer part
	str[pos++] = '.';  // add decimal point to string

	while (pos < (size + len + 1))  // process remaining digits
	{
		f = f - (float) value;  // hack off the whole part of the number
		f *= 10;  // move next digit over
		value = (int) f;  // get next digit
		itoa(value, curr, 10); // convert digit to string
		str[pos++] = *curr; // add digit to result string and increment pointer
	}
}

uint8_t convertHourTo(uint8_t hour, int offset) {
	return (hour + offset) > 23 ? ((hour + offset) - 24) : (hour + offset);
}

void BSP_Led_Write(uint8_t state) {
	HAL_GPIO_WritePin(LD6_GPIO_Port, LD6_Pin, state);
	HAL_GPIO_WritePin(LD5_GPIO_Port, LD5_Pin, state);
	HAL_GPIO_WritePin(LD4_GPIO_Port, LD4_Pin, state);
	HAL_GPIO_WritePin(LD3_GPIO_Port, LD3_Pin, state);
}

void BSP_Led_Toggle(void) {
	HAL_GPIO_TogglePin(LD6_GPIO_Port, LD6_Pin);
	HAL_GPIO_TogglePin(LD5_GPIO_Port, LD5_Pin);
	HAL_GPIO_TogglePin(LD4_GPIO_Port, LD4_Pin);
	HAL_GPIO_TogglePin(LD3_GPIO_Port, LD3_Pin);
}

void Get_RTC(char *dateTime) {
	RTC_TimeTypeDef currentTime;
	RTC_DateTypeDef currentDate;

	// get the RTC
	HAL_RTC_GetTime(&hrtc, &currentTime, RTC_FORMAT_BIN);
	HAL_RTC_GetDate(&hrtc, &currentDate, RTC_FORMAT_BIN);

	// combine RTC datetime
	sprintf(dateTime, "20%02d%02d%02d%02d%02d%02d", currentDate.Year, currentDate.Month, currentDate.Date, currentTime.Hours,
			currentTime.Minutes, currentTime.Seconds);
}

void Set_RTC(char *dateTime) {
	// format dateTime: YYYYMMDDHHMMSS
	char Y[2], M[2], D[2], H[2], I[2], S[2];
	RTC_TimeTypeDef currentTime;
	RTC_DateTypeDef currentDate;

	// parsing
	strncpy(Y, dateTime + 2, 2);
	strncpy(M, dateTime + 4, 2);
	strncpy(D, dateTime + 6, 2);
	strncpy(H, dateTime + 8, 2);
	strncpy(I, dateTime + 10, 2);
	strncpy(S, dateTime + 12, 2);

	// assing to object
	currentDate.WeekDay = RTC_WEEKDAY_SUNDAY; // day is ignored
	currentDate.Year = atoi(Y);
	currentDate.Month = atoi(M);
	currentDate.Date = atoi(D);
	currentTime.Hours = atoi(H);
	currentTime.Minutes = atoi(I);
	currentTime.SecondFraction = atoi(S);

	// set the RTC
	HAL_RTC_SetTime(&hrtc, &currentTime, RTC_FORMAT_BIN);
	HAL_RTC_SetDate(&hrtc, &currentDate, RTC_FORMAT_BIN);
}

